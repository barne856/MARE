#version 450 core

layout(local_size_x = 4) in;

struct Velocity {
    float x, y, z;
};

layout(std430) buffer model_instances
{
    mat4 models[];
};

layout(std430) buffer model_instances_out
{
    mat4 models_out[];
};

layout(std430) buffer particle_velocities
{
    Velocity velocities[];
};

layout(std430) buffer particle_velocities_out
{
    Velocity velocities_out[];
};

uniform float dt = 0.01;
uniform float G = 1.0;

vec3 direction(mat4 m1, mat4 m2)
{
    // m1 <-- m2
    return normalize(m1[3].xyz - m2[3].xyz);
}

float model_dist(mat4 m1, mat4 m2)
{
    return length(m1[3].xyz - m2[3].xyz);
}

shared vec3 force;

void main(void)
{    
    uint index = gl_WorkGroupID.x;
    // update force (sum of forces from all other bodies) on first invocation of local group
    if(gl_LocalInvocationID.x == 0)
    {
        force = vec3(0.0);
        for(int i = 0; i < models.length(); i++)
        {
            vec3 p1 = models[i][3].xyz;
            vec3 p2 = models[index][3].xyz;
            float r = length(p1 - p2);
            if(r > 0.003) // singularity
            {
                force += G * (p1-p2)/pow(r,3.0);
            }
        }
    }
    barrier();


    // update position and velocity
    if(gl_LocalInvocationID.x == 1)
    {
        velocities_out[index].x = velocities[index].x + force.x*dt;
        models_out[index][3].x = models[index][3].x + velocities[index].x*dt;
    }
    else if(gl_LocalInvocationID.x == 2)
    {
        velocities_out[index].y = velocities[index].y + force.y*dt;
        models_out[index][3].y = models[index][3].y + velocities[index].y*dt;
    }
    else if(gl_LocalInvocationID.x == 3)
    {
        velocities_out[index].z = velocities[index].z + force.z*dt;
        models_out[index][3].z = models[index][3].z + velocities[index].z*dt;
    }
}